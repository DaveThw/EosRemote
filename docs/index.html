<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
<!--<html>-->
<!-- Doesn't seem to work with <!DOCTYPE html> at the top... -->
<!-- <head>-->
  <title>Ion OSC Remote</title>
<!--  <meta charset="UTF-8">-->
<!--  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> -->
<!--  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, target-densitydpi=device-dpi"> -->
  <meta name="viewport" content="user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#000000">
  <script src='js/interface.js'></script>
  <script src='js/interface.client.js'></script>
  <style>
    html, body {
      padding:    0;
      margin:     0;
      height:     100%;
      width:      100%;
      background: black;
    }
    div.tab_panel {
      width:    100%;
      height:   5%;
      display:  block;
      margin:   0;
      padding:  0;
      // position: absolute;
      // left:     0;
      // top:      0;
    }
    div.osc_panel {
      width:    100%;
      height:   95%;
      display:  block;
      margin:   0;
      padding:  0;
      // position: absolute;
      // left:     0;
      // top:      10%;
    }
  </style>
</head>
<body>
  <div id='tab_panel' class='tab_panel'></div>
  <div id='osc_panel' class='osc_panel'></div>
  <script>    
    /* You can manually send WebSocket messages with the following syntax:
    *
    *  Interface.Socket.send( 
    *    JSON.stringify({ type:'socket', address:'/yourAddress', parameters:[ 0, 'test', {hello:'hi'} ] }) 
    *  );
    *
    *  Interface.Socket is a normal WebSocket object, however, using the above syntax ensures that messages
    *  will be distributed to all clients connected to the interface.js simpleserver
    */
    

    var fontSize = Math.min(Math.round(window.innerHeight / 40), Math.round(window.innerWidth / 25));

    var panels = {};
    panels['top']  = make_top_panel();
    panels[1]      = make_control_panel();
    panels[2]      = make_smoke_panel();
    panels[3]      = make_playback_panel();
    panels[4]      = make_faders_panel();
    panels[5]      = make_stats_panel();
    panels['menu'] = make_menu_panel();




    function pageChange(setHash, button) {
      if (setHash) window.location.hash=button.hash;

      for( var j = 0; j < panels['menu'].children.length; j++) {
        var child = panels['menu'].children[j];
        
        //console.log( "CHECK", child.key, msg.address )
        if (child.page) {
          if( child === button ) {
            child.page.canvas.style.display = 'block';
            child.page.active = true;
            child.setValue(1, false);
            child.page.refresh();
            // menuButton.label = child.label;
            menuButton.selectedButton = child;
            menuButton.selectedPage = child.page;
          } else {
            child.page.canvas.style.display = 'none';
            child.page.active = false;
            child.setValue(0, false);
          }
          child.background = undefined;
        }
      }

      if (button === menuButton) {
        if (menuButton.value == 1) {
          // menu button is / has just been selected (ie. show menu)
          panels['menu'].canvas.style.display = 'block';
          panels['menu'].active = true;
          // menuButton.setValue(1, false);
          if (menuButton.selectedButton) {
            // menuButton.selectedButton.setValue(1, false);
            menuButton.selectedButton.background = menuButton.selectedButton.panel.childFill;
          }
          panels['menu'].refresh();
        } else {
          // menu button has just been un-selected (ie. close menu)
          // but... we only want to close the menu if we actually have an item seleted
          if (menuButton.selectedPage) {
            panels['menu'].canvas.style.display = 'none';
            panels['menu'].active = false;
            menuButton.selectedPage.canvas.style.display = 'block';
            menuButton.selectedPage.active = true;
            menuButton.selectedPage.refresh();
          } else {
            panels['menu'].canvas.style.display = 'block';
            panels['menu'].active = true;
            menuButton.setValue(1, false);
            panels['menu'].refresh();
          }
        }
      } else {
        // ensure menu is hidden, and button is un-selected
        panels['menu'].canvas.style.display = 'none';
        panels['menu'].active = false;
        menuButton.setValue(0, false);
      }
    }

    function hashChange() {
      var hash=window.location.hash.replace(/^#/,"");
      var button=menuButton;
      if ( hash != "" ) {
        for ( var child in panels['menu'].children) {
          if ( panels['menu'].children[child].hash !== null ) {
            if ( panels['menu'].children[child].hash == hash) button=panels['menu'].children[child];
          }
        }
      } else {
        // menuButton.label = "Menu";
        menuButton.selectedButton = null;
        menuButton.selectedPage = null;
        menuButton.setValue(1, false);
      }
      pageChange(false, button);
    }
    hashChange();
    window.onhashchange = hashChange;

    // might need to put our panel inside our own <div> with 100% width and height..?
    window.onresize = function() {
      canvasResize();
      showStats();
    };

  function setup_websocket() {

    if (Interface.Socket && Interface.Socket.readyState !== WebSocket.CLOSED) {
      console.log( "Websocket: Existing connection seems fine - keeping it and adding event handlers, at "+timeLabel.value+"..." );
      // console.log( "Websocket: Discarding old connection at "+timeLabel.value+"..." );
      // console.log( "Websocket: Closing old connection at "+timeLabel.value+"..." );
      // Interface.Socket.close();
    } else {
      console.log( "Websocket: Trying new connection at "+timeLabel.value+"..." );
      Interface.Socket = new WebSocket( socketString );
      Interface.OSC.socket = Interface.Socket;
      Interface.MIDI.socket = Interface.Socket;
    }

    Interface.Socket.onmessage = function (event) {
      var data = JSON.parse( event.data )
      if( data.type === 'osc' ) {
        Interface.OSC._receive( event.data );
      }else {
        if( Interface.Socket.receive ) {
          Interface.Socket.receive( data.address, data.parameters  )
        }
      }
    };

    Interface.Socket.onopen = function (event) {
      Interface.Socket.send( 
        JSON.stringify({ type:'socket', address:'/osc/init', parameters:[] })
      //  JSON.stringify({ type:'socket', address:'/osc/status', parameters:[ 'init' ] })
      );
      // Interface.Socket.send( 
      //   JSON.stringify({ type:'socket', address:'/eos/reset', parameters:[] })
      // );
      websocketStatus.setValue(timeLabel.value+' - Connected');
      console.log( "Websocket: Connected at "+timeLabel.value );
      statusWebsocket.setValue(1);
    };

    Interface.Socket.onclose = function (event) {
      websocketStatus.setValue(timeLabel.value+' - Closed');
      console.log( "Websocket: Closed at "+timeLabel.value );
      statusWebsocket.setValue(0);
    };

    Interface.Socket.onerror = function (event) {
      websocketStatus.setValue(timeLabel.value+' - Error');
      console.log( "Websocket: Error at "+timeLabel.value );
    };

    // override to process WebSocket messages. Messages that a client sends are not echoed back by the server,
    // and are only sent to other connected clients.
    Interface.Socket.receive = function( address, parameters ) {
      console.log( address, parameters )
    }
  }

    function check_websocket(){
      if(!Interface.Socket || Interface.Socket.readyState === WebSocket.CLOSED) setup_websocket();
    }

    setup_websocket();

    setInterval(check_websocket, 5000);

    function showStats() {
      var tabpanelHeight = document.querySelector("#tab_panel").clientHeight;
      var tabpanelWidth = document.querySelector("#tab_panel").clientWidth;
      var panelHeight = document.querySelector("#osc_panel").clientHeight;
      var panelWidth = document.querySelector("#osc_panel").clientWidth;
    //  var panelHeight = document.getElementsByTagName("div")[0].clientHeight;
    //  var panelWidth = document.getElementsByTagName("div")[0].clientWidth;
      var canvasWidth = panels[1].canvas.width;
      var canvasHeight = panels[1].canvas.height;
      var viewportWidth = document.documentElement.clientWidth;
      var viewportHeight = document.documentElement.clientHeight;
      var scrollHeight = document.documentElement.scrollHeight;
      var windowHeight = window.outerHeight;
      // var fontSize = Math.min(Math.round(panelHeight / 40), Math.round(panelWidth / 25));
      var fontSize = Math.min(Math.round(window.innerHeight / 40), Math.round(window.innerWidth / 25));
      var devicePixelRatio = window.devicePixelRatio || 1;
      var context = panels[1].canvas.getContext('2d');
      var backingStoreRatio = context.webkitBackingStorePixelRatio ||
                          context.mozBackingStorePixelRatio ||
                          context.msBackingStorePixelRatio ||
                          context.oBackingStorePixelRatio ||
                          context.backingStorePixelRatio || 1;
      var ratio = devicePixelRatio / backingStoreRatio;

      scrollSizeStatus.setValue(document.documentElement.scrollWidth+' x '+scrollHeight+'px');
      windowInnerSizeStatus.setValue(window.innerWidth+' x '+window.innerHeight+'px');
      windowOuterSizeStatus.setValue(window.outerWidth+' x '+window.outerHeight+'px');
      canvasSizeStatus.setValue(canvasWidth+' x '+canvasHeight+'px');
      tabPanelSizeStatus.setValue(tabpanelWidth+' x '+tabpanelHeight+'px');
      viewportSizeStatus.setValue(viewportWidth+' x '+viewportHeight+'px');
      fontSizeStatus.setValue(fontSize+'px');
      ratiosStatus.setValue(devicePixelRatio+' / '+backingStoreRatio);
      userAgentStatus.setValue(navigator.userAgent);
      // Dave's HTC:        Mozilla/5.0 (Linux; Android 5.0.2; HTC One Build/LRX22G) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.85 Mobile Safari/537.36
      // Dave's Chromebook: Mozilla/5.0 (X11; CrOS x86_64 8743.85.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.101 Safari/537.36
      // Hudl:              Mozilla/5.0 (Linux; Android 5.1; Hudl 2 Build/LMY47I) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.85 Safari/537.36
      // Nath's iPhone: 
      // iPad: 
      // Chrome on Dave's PC: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari 537.36

    };

    function canvasResize() {
    //  var fontSize = Math.min(Math.round(panelHeight / 40), Math.round(panelWidth / 25));
      var fontSize = Math.min(Math.round(window.innerHeight / 40), Math.round(window.innerWidth / 25));

      for (var i = 0; i < Interface.panels.length; i++) {
        Interface.panels[i].font = 'normal '+fontSize+'px sans-serif';
        for (var j = 0; j < Interface.panels[i].children.length; j++) {
          var child = Interface.panels[i].children[j];
          if (child.size !== undefined)
            child.size=(child.relativeFontSize?child.relativeFontSize:1)*fontSize;
          if (child.type=="Button" && child.font !== undefined)
            child.font='normal ' + ((child.relativeFontSize?child.relativeFontSize:1)*fontSize) + 'px sans-serif';
/*
          if (child.element !== undefined) {
            child.element.css({
              fontSize: fontSize,
              left: child._x() + child.panel.x,
              top: child._y() + child.panel.y,
              width: child._width(),
              height: child._height(),
            });
          }
*/
        }
        Interface.panels[i].redoBoundaries.call(Interface.panels[i]);
      }
    };

    Interface.OSC.callbacks['/eos/out/active/cue/text'] = function(args) {
      //console.log( args )
      // first process the raw text a little...
      var res=args[0].match(/^(([0-9]+)\/)?([0-9.]+)?( (.*))? ([0-9.:]+) ([0-9.]+)%$/);
      // res[0] = "<Original OSC String>"
      // res[1] = "<Cue List>/" (if present)
      // res[2] = "<Cue List>" (if present)
      // res[3] = "<Cue Number>" (if present)
      // res[4] = " <Cue Label>" (if present)
      // res[5] = "<Cue Label>" (if present)
      // res[6] = "<Cue Time>" (time remaining whilst cue is running, or programmed cue time once complete)
      // res[7] = "<Cue Percentage Complete>" (whole number only - without trailing '%')
      //console.log( res );

//      if (res) {
//        top_tab_cue_text.setValue("Q"+(res[1]=="2"?'':res[2]+'/')+(res[3]=="0"?' --':res[3])+(res[4]?res[4]:""));
//      } else {
//        top_tab_cue_text.setValue(args[0]);
//      }
      // next, set any widgets that are just looking for the 'raw' text value:
      for(var i = 0; i < Interface.panels.length; i++) {
        for( var j = 0; j < Interface.panels[i].children.length; j++) {
          var child = Interface.panels[i].children[j];
          
          //console.log( "CHECK", child.key, '/eos/out/active/cue/text' )
          switch (child.key) {
            case '/eos/out/active/cue/text':
              //console.log( child.key, args )
              child.setValue.apply( child, args );
              // return;
              break;
            case '/eos/out/active/cue/text/number+label':
              child.setValue.apply( child, [ "Q"+(res[2]==undefined?'':res[2]+'/')+(res[3]==undefined?'--':res[3])+(res[4]?res[4]:"") ] );
              break;
            case '/eos/out/active/cue/text/number':
              child.setValue.apply( child, [ (res[2]==undefined?'':res[2]+'/')+(res[3]==undefined?'--':res[3]) ] );
              break;
            case '/eos/out/active/cue/text/label':
              child.setValue.apply( child, [ (res[5]?res[5]:"") ] );
              break;
            case '/eos/out/active/cue/text/time':
              child.setValue.apply( child, [ res[6] ] );
              break;
          }
        }
      }
    }

    Interface.OSC.callbacks['/eos/out/pending/cue/text'] = function(args) {
      //console.log( args )
      // first process the raw text a little...
      var res=args[0].match(/^(([0-9]+)\/)?([0-9.]+)( (.*))? ([0-9.:]+)$/);
      // res[0] = "<Original OSC String>"
      // res[1] = "<Cue List>/" (if present)
      // res[2] = "<Cue List>" (if present)
      // res[3] = "<Cue Number>"
      // res[4] = " <Cue Label>" (if present)
      // res[5] = "<Cue Label>" (if present)
      // res[6] = "<Cue Time>" (programmed cue time)

      //console.log( res );
      // next, set any widgets that are just looking for the 'raw' text value:
      for(var i = 0; i < Interface.panels.length; i++) {
        for( var j = 0; j < Interface.panels[i].children.length; j++) {
          var child = Interface.panels[i].children[j];
          
          //console.log( "CHECK", child.key, '/eos/out/pending/cue/text' )
          switch (child.key) {
            case '/eos/out/pending/cue/text':
              //console.log( child.key, args )
              child.setValue.apply( child, args );
              // return;
              break;
            case '/eos/out/pending/cue/text/number+label':
              child.setValue.apply( child, [ "Q"+(res[2]==undefined?'':res[2]+'/')+(res[3]==undefined?'--':res[3])+(res[4]?res[4]:"") ] );
              break;
            case '/eos/out/pending/cue/text/number':
              child.setValue.apply( child, [ (res[2]==undefined?'':res[2]+'/')+(res[3]==undefined?'--':res[3]) ] );
              break;
            case '/eos/out/pending/cue/text/label':
              child.setValue.apply( child, [ (res[5]?res[5]:"") ] );
              break;
            case '/eos/out/pending/cue/text/time':
              child.setValue.apply( child, [ res[6] ] );
              break;
          }
        }
      }
    }

    Interface.OSC.callbacks['/eos/out/event/state'] = function(args) {
      // console.log( args )
      // liveBlind.setValue(args[0]==1 ? 'Live' : 'Blind')
      for(var i = 0; i < Interface.panels.length; i++) {
        for( var j = 0; j < Interface.panels[i].children.length; j++) {
          var child = Interface.panels[i].children[j];
          
          if( child.key === '/osc/eos/state' ) {
            if (args[0]===1) child.setValue.apply( child, ['Live'] );
            else if (args[0]===1) child.setValue.apply( child, ['Blind'] );
            else child.setValue.apply( child, args );
          }
        }
      }
    }

    Interface.OSC.callbacks['/eos/out/cmd'] = function(args) {
      //console.log( args )
      // first process the raw text a little...
      var res=args[0][0].match(/^([^:]+): (([^ ]+) +([0-9.]+)) : (.*)$/);
      // res == undefined, if no match found...
      // res[0] = "<Original OSC String>"
      // res[1] = "LIVE|BLIND|other..."
      // res[2] = "[Cue|Sub|other...] <Number>"
      // res[3] = "Cue|Sub|other..."
      // res[4] = "<Cue (or whatever) Number>"
      // res[5] = "<Command Line Text>"
      // args[0][1] = "[0|1]" (0 for all okay, 1 for command line error)
      //console.log( res );

      // next, set any widgets that are just looking for the 'raw' text value:
      for(var i = 0; i < Interface.panels.length; i++) {
        for( var j = 0; j < Interface.panels[i].children.length; j++) {
          var child = Interface.panels[i].children[j];
          
          switch (child.key) {
            case '/eos/out/cmd':
              //console.log( child.key, args )
              child.setValue.apply( child, [ (res==undefined ? args[0][0] : res[0]) + (args[0][1]==1 ? " *Error*" : "") ] );
              // return;
              break;
            case '/eos/out/cmd/text':
              child.setValue.apply( child, [ (res==undefined ? args[0][0] : res[5]) + (args[0][1]==1 ? " *Error*" : "") ] );
              break;
          }
        }
      }
    }




/***************************************************************************************\
*                                                                                       *
*                                     TOP PANEL                                         *
*                                                                                       *
\***************************************************************************************/

  function make_top_panel () {
     
    panel = new Interface.Panel({
      useRelativeSizesAndPositions: true,
      container:document.querySelector("#tab_panel"),
    });
    panel.background = '#333';
    panel.canvas.style.width = '100%';
    panel.canvas.style.height = '100%';
    panel.canvas.style.display = 'block';
    panel.font = 'normal '+fontSize+'px sans-serif';

    var x_base, y_base, button_width, button_height, margin, x, y;

    x_base=.00; y_base=.10; button_width=.20; button_height=.80; margin=0.01;
    x=0; y=0;
    function menuButton_valueChange() {
      pageChange(false, this);
    }
    panel.add( menuButton = new Interface.Button({
//      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width*2-2*margin, button_height-2*margin],
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/osc/menu',
      mode: 'toggle',
      label: 'Menu',
      hash: '',
      value: 1,
      selectedPage: null,
      selectedButton: null,
      onvaluechange: menuButton_valueChange,
    }) );
    panel.add( top_tab_cue_text = new Interface.Label({
      bounds: [x_base+x*button_width+margin, y_base+y*button_height+margin, (button_width*6/4)-2*margin, button_height-2*margin],
      value: "Cue...",
      key: '/eos/out/active/cue/text/number+label',
      hAlign: 'left',
      vAlign: 'middle',
      size: fontSize,
      stroke: '#fff',
    }) );
    panel.add( new Interface.Slider({
      bounds: [x_base+x*button_width+margin, y_base+(y+1)*button_height, (button_width*6/4)-2*margin, 1-(y_base+(y+1)*button_height)],
      key: '/eos/out/active/cue',
      isVertical: false,
      background: '#770',
      fill: '#ff0',
      stroke: panel.background,
      changeValue: function( xOffset, yOffset ) {},
    }) );
    x+=6/4;
    panel.add( new Interface.Label({
      bounds: [x_base+x*button_width+margin, y_base+y*button_height+margin, (button_width*1/2)-2*margin, button_height-2*margin],
      value: "User:",
      hAlign: 'right',
      vAlign: 'middle',
      size: fontSize,
    }) ); x+=1/2;
    panel.add( new Interface.Label({
      bounds: [x_base+x*button_width+margin, y_base+y*button_height+margin, (button_width*1/4)-2*margin, button_height-2*margin],
      value: "?",
      size: fontSize,
      key: '/eos/out/user',
      hAlign: 'left',
      vAlign: 'middle',
      background: '#f00', // not used for a Label
      stroke: '#fff',     // text colour
      fill: '#00f',       // not used for a Label
    }) ); x+=1/4;

    // live / blind state
    // panel.add( new Interface.Label({
    panel.add( liveBlind = new Interface.Label({
      bounds: [x_base+x*button_width+margin, y_base+y*button_height+margin, (button_width*1/2)-2*margin, button_height-2*margin],
      value: "???",
      vAlign: 'middle',
      size: fontSize,
      key: '/osc/eos/state',
      stroke: '#fff',
    }) ); x+=1/2;

    panel.add( timeLabel = new Interface.Label({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: '??:??:??',
      size: fontSize,
      hAlign: 'left',
      vAlign: 'middle',
//      stroke: '#fff',
      timer: null,
      getCurrentTime: function(button) {
        var currentTime = new Date();
        var hours = currentTime.getHours();
        var minutes = currentTime.getMinutes();
        var seconds = currentTime.getSeconds();
        var ampm = "am";
        
        if (hours >= 12) {
          hours = hours - 12;
          ampm = "pm";
        }
        if (hours == 0)
          hours = 12;
        
        if (minutes < 10)
          minutes = "0" + minutes;
        
        if (seconds < 10)
          seconds = "0" + seconds;
        
        button.setValue(hours + ":" + minutes + ":" + seconds + " " + ampm);
        
      },
      oninit: function() {
        this.getCurrentTime(this);
        this.timer = setInterval(this.getCurrentTime, 1000, this);
      },
    }) );
    panel.add( statusWebsocket = new Interface.Button({
      bounds: [0.95, 0.1, 0.04, 0.2],
      mode: 'toggle',
      background: '#f00', // fill colour (when not pressed)
      stroke: '#ccc',     // text colour, and border colour
      fill: '#0f0',       // fill colour (when pressed)
      changeValue: function( xOffset, yOffset ) {},
    }) );
    panel.add( statusPing = new Interface.Button({
      bounds: [0.95, 0.4, 0.04, 0.2],
      mode: 'toggle',
      background: '#060', // fill colour (when not pressed)
      stroke: '#ccc',     // text colour, and border colour
      fill: '#0f0',       // fill colour (when pressed)
      changeValue: function( xOffset, yOffset ) {},
    }) );
    panel.add( statusReceived = new Interface.Button({
      bounds: [0.95, 0.7, 0.04, 0.2],
      mode: 'toggle',
      background: '#060', // fill colour (when not pressed)
      stroke: '#ccc',     // text colour, and border colour
      fill: '#0f0',       // fill colour (when pressed)
      changeValue: function( xOffset, yOffset ) {},
      timeout: null,
    }) );

    Interface.OSC._receive = function( data ) {
      var msg = JSON.parse( data );

      if ( statusReceived.timeout ) clearTimeout(statusReceived.timeout)
      statusReceived.setValue(1);
      statusReceived.timeout = setTimeout( function() {statusReceived.timeout=null; statusReceived.setValue(0)}, 500);

      if( msg.address in this.callbacks ) {
        this.callbacks[ msg.address ]( msg.parameters );
      }else{
        for(var i = 0; i < Interface.panels.length; i++) {
          for( var j = 0; j < Interface.panels[i].children.length; j++) {
            var child = Interface.panels[i].children[j];
            
            //console.log( "CHECK", child.key, msg.address )
            if( child.key === msg.address ) {
              //console.log( child.key, msg.parameters )
              child.setValue.apply( child, msg.parameters );
              //return;
            }
          }
        }
        this.receive( msg.address, msg.typetags, msg.parameters );
      }
    }

  return panel; }




/***************************************************************************************\
*                                                                                       *
*                                    MENU PANEL                                         *
*                                                                                       *
\***************************************************************************************/

  function make_menu_panel () {
    
    panel = new Interface.Panel({
      useRelativeSizesAndPositions: true,
      container:document.querySelector("#osc_panel"),
    });
    panel.background = '#222';
    panel.canvas.style.width = '100%';
    panel.canvas.style.height = '100%';
    panel.font = 'normal '+fontSize+'px sans-serif';

    var x_base, y_base, button_width, button_height, margin, x, y;

    x_base=.00; y_base=.00; button_width=.50; button_height=.10; margin=0.01;
    x=0; y=0;

    function menuItem_valueChange() {
      if ( this.value == 1) {
        // key-down / press
        if (menuButton.selectedButton && menuButton.selectedButton!==this) {
          // delete menuButton.selectedButton.background;
          menuButton.selectedButton.background = undefined;
          menuButton.selectedButton.refresh();
        }
      } else {
        // key-up / release
        pageChange(true, this);
      }
    }
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/osc/page1',
      mode: 'momentary',
      label: 'Control',
      hash: 'control',
      page: panels[1],
      onvaluechange: menuItem_valueChange,
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/osc/page2',
      mode: 'momentary',
      label: 'Smoke',
      hash: 'smoke',
      page: panels[2],
      onvaluechange: menuItem_valueChange,
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/osc/page3',
      mode: 'momentary',
      label: 'Playback',
      hash: 'playback',
      page: panels[3],
      onvaluechange: menuItem_valueChange,
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/osc/page4',
      mode: 'momentary',
      label: 'Faders',
      hash: 'faders',
      page: panels[4],
      onvaluechange: menuItem_valueChange,
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/osc/page5',
      mode: 'momentary',
      label: 'Stats',
      hash: 'stats',
      page: panels[5],
      onvaluechange: menuItem_valueChange,
    }) );

  return panel; }





/***************************************************************************************\
*                                                                                       *
*                                    SMOKE PANEL                                        *
*                                                                                       *
\***************************************************************************************/

  function make_smoke_panel () {
    
    panel = new Interface.Panel({
      useRelativeSizesAndPositions: true,
      container:document.querySelector("#osc_panel"),
    });
    panel.background = '#222';
    panel.canvas.style.width = '100%';
    panel.canvas.style.height = '100%';
    panel.font = 'normal '+fontSize+'px sans-serif';

    var x_base, y_base, button_width, button_height, margin, x, y;

    x_base=.00; y_base=.10; button_width=.20; button_height=.80; margin=0.01;
    x=0; y=0;

    panel.add( smokeStatus = new Interface.Label({
      bounds: [.20+margin, .10+margin, .60-2*margin, .10-2*margin],
      value: "Smoke: ??",
      relativeFontSize: 2,
      size: fontSize*2,
    }) );
    Interface.OSC.callbacks['/eos/out/event/sub/5'] = function(args) {
      // console.log( args )
      smokeStatus.setValue(args[0]==1 ? 'SMOKE: ON!' : 'Smoke: Off')
    }
    panel.add( new Interface.Button({
      bounds: [.20+margin, .20+margin, .60-2*margin, .60-2*margin],
      target: "WebSocket", key: '/eos/sub/5/fire',
      mode: 'momentary',
      label: 'Smoke!',
      background: '#900', // fill colour (when not pressed)
      stroke: '#ccc',     // text colour, and border colour
      fill: '#f00',       // fill colour (when pressed)
      relativeFontSize: 3,
      font: 'normal '+(3*fontSize)+'px sans-serif',
    }) );

  return panel; }




/***************************************************************************************\
*                                                                                       *
*                                    STATS PANEL                                        *
*                                                                                       *
\***************************************************************************************/

  function make_stats_panel () {
    
    panel = new Interface.Panel({
      useRelativeSizesAndPositions: true,
      container:document.querySelector("#osc_panel"),
    });
    panel.background = '#222';
    panel.canvas.style.width = '100%';
    panel.canvas.style.height = '100%';
    panel.font = 'normal '+fontSize+'px sans-serif';

    var x_base, y_base, button_width, button_height, margin, x, y;

    x_base=.00; y_base=.00; button_width=.20; button_height=.05; margin=0.010;
    x=0; y=0;

    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/reset',
      mode: 'contact',
      label: 'Reset',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/user',
      max: 0,
      mode: 'contact',
      label: 'User 0',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/user',
      max: 1,
      mode: 'contact',
      label: 'User 1',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/user',
      max: 2,
      mode: 'contact',
      label: 'User 2',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/user',
      max: 2400,
      mode: 'contact',
      label: 'User 2400',
    }) );

    x_base=.00; y_base=.05; button_width=.20; button_height=.035; margin=0.001;
    x=0; y=0;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "My IP:",
      size: fontSize,
    }) );
    panel.add( ipText = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??.??.??.??",
      size: fontSize,
      hAlign: 'left',
      stroke: '#fff',
      /* This code taken from: */
      /*  http://stackoverflow.com/questions/391979/how-to-get-clients-ip-address-using-javascript-only#answer-32841164 */
      oninit: function() {
        var myPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; //compatibility for firefox and chrome

        if (!myPeerConnection) {
          ipText.setValue('Cannot get IP address as no WebRTC support...');
        } else {
          ipText.setValue('WebRTC:');
          var pc = new myPeerConnection({iceServers: []}),
              noop = function() {},
              localIPs = {},
              // ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/g,
              ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/g,
              key;
          
          function ipIterate(ip) {
            if (!localIPs[ip]) {
              console.log('IP: '+ip);
              ipText.setValue(ipText.value+" "+ip);
            }
            localIPs[ip] = true;
          }
          
          pc.createDataChannel(""); //create a bogus data channel
          pc.createOffer(function(sdp) {
            sdp.sdp.split('\n').forEach(function(line) {
              // console.log('line: '+line);
              if (line.indexOf('candidate') < 0) return;
              line.match(ipRegex).forEach(ipIterate);
            });
            pc.setLocalDescription(sdp, noop, noop);
          }, noop); // create offer and set local description
          pc.onicecandidate = function(ice) { //listen for candidate events
            if (!ice || !ice.candidate || !ice.candidate.candidate || !ice.candidate.candidate.match(ipRegex)) return;
            // console.log('ice.candidate.candidate: '+ice.candidate.candidate);
            ice.candidate.candidate.match(ipRegex).forEach(ipIterate);
          };
        }
      },
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Tab Panel size:",
      size: fontSize,
    }) );
    panel.add( tabPanelSizeStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Canvas size:",
      size: fontSize,
    }) );
    panel.add( canvasSizeStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Viewport size:",
      size: fontSize,
    }) );
    panel.add( viewportSizeStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Window Inner size:",
      size: fontSize,
    }) );
    panel.add( windowInnerSizeStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Window Outer size:",
      size: fontSize,
    }) );
    panel.add( windowOuterSizeStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Scroll size:",
      size: fontSize,
    }) );
    panel.add( scrollSizeStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Ratios:",
      size: fontSize,
    }) );
    panel.add( ratiosStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Font size:",
      size: fontSize,
    }) );
    panel.add( fontSizeStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "User Agent:",
      size: fontSize,
    }) );
    y++
    panel.add( userAgentStatus = new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, (1.0)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
      oninit: function() {
        showStats();
      },
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Websocket:",
      size: fontSize,
    }) );
    panel.add( websocketStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "TCP Ping (RPi to Ion):",
      size: fontSize,
    }) );
    panel.add( tcpPingStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
    }) );
    Interface.OSC.callbacks['/osc/ping/ion'] = function(args) {
      // console.log( args )
      tcpPingStatus.setValue(timeLabel.value + ' - ' + (args[0]===false ? 'Failed' : args[0]+'mS'));
    }
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "OSC Ping (Page to RPi):",
      size: fontSize,
    }) );
    panel.add( oscPingStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
      timer: null,
      id: ''+Math.floor(Math.random() * 1000),
      pingRPi: function(id) {
        var currentTime = new Date();
	var msTime = currentTime.getTime();
        oscPingStatus.setValue(timeLabel.value + ' - ' + 'id: ' + id + ' - ' + 'sent...');
        Interface.OSC.send( '/osc/ping', 'S', id+":"+msTime );
        // statusPing.setValue(0)
      },
      oninit: function() {
        setTimeout(this.pingRPi, 1000, this.id);
        this.timer = setInterval(this.pingRPi, 5000, this.id);
      },
    }) );
    Interface.OSC.callbacks['/osc/pong'] = function(args) {
      // console.log( args )
      var currentTime = new Date();
      var ping = (""+args[0]).split(':');
      // oscPingStatus.setValue(timeLabel.value + ' - ' + currentTime.getTime() + " - " + args[0] + " = " + (currentTime.getTime() - args[0]) + "mS");
      // oscPingStatus.setValue(timeLabel.value + ' - ' + 'id: ' + args[0] + ' - ' + (currentTime.getTime() - args[1]) + "mS");
      // oscPingStatus.setValue(timeLabel.value + ' - ' + args[0]);
      if (ping[0] == oscPingStatus.id) {
        oscPingStatus.setValue(timeLabel.value + ' - ' + 'id: ' + ping[0] + ' - ' + (currentTime.getTime() - ping[1]) + "mS");
        // statusPing.setValue(1)
      }
    }
    y++;

    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "OSC Ping (Page to Ion):",
      size: fontSize,
    }) );
    panel.add( eosPingStatus = new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "??",
      size: fontSize,
      stroke: '#fff',
      hAlign: 'left',
      timer: null,
      id: ''+Math.floor(Math.random() * 1000),
      pingIon: function(id) {
        var currentTime = new Date();
	var msTime = currentTime.getTime();
        eosPingStatus.setValue(timeLabel.value + ' - ' + 'id: ' + id + ' - ' + 'sent...');
        Interface.OSC.send( '/eos/ping', 'S', id+":"+msTime );
        // Interface.Socket.send( 
        //   JSON.stringify({ type:'socket', address:'/eos/ping', parameters:[ id+":"+msTime ] })
        // );
        // not quite sure why, but this doesn't seem to work right as parameters:[ msTime ], but does as parameters:[ ""+msTime ]
        // my best guess is that OSC doesn't handle large integers well, but converting it to a string solves the problem..?
        statusPing.setValue(0)
      },
      oninit: function() {
        setTimeout(this.pingIon, 1000, this.id);
        this.timer = setInterval(this.pingIon, 10000, this.id);
      },
    }) );
    Interface.OSC.callbacks['/eos/out/ping'] = function(args) {
      // console.log( args )
      var currentTime = new Date();
      var ping = (""+args[0]).split(':');
      // eosPingStatus.setValue(timeLabel.value + ' - ' + currentTime.getTime() + " - " + args[0] + " = " + (currentTime.getTime() - args[0]) + "mS");
      // eosPingStatus.setValue(timeLabel.value + ' - ' + 'id: ' + args[0] + ' - ' + (currentTime.getTime() - args[1]) + "mS");
      // eosPingStatus.setValue(timeLabel.value + ' - ' + args[0]);
      if (ping[0] == eosPingStatus.id) {
        eosPingStatus.setValue(timeLabel.value + ' - ' + 'id: ' + ping[0] + ' - ' + (currentTime.getTime() - ping[1]) + "mS");
        statusPing.setValue(1)
      }
    }
    y++;

  return panel; }




/***************************************************************************************\
*                                                                                       *
*                                  CONTROL PANEL                                        *
*                                                                                       *
\***************************************************************************************/

  function make_control_panel () {
    
    panel = new Interface.Panel({
      useRelativeSizesAndPositions: true,
      container:document.querySelector("#osc_panel"),
    });
    panel.background = '#222';
    panel.canvas.style.width = '100%';
    panel.canvas.style.height = '100%';
    panel.font = 'normal '+fontSize+'px sans-serif';

    var x_base, y_base, button_width, button_height, margin, x, y;

    x_base=.00; y_base=.00; button_width=.25; button_height=.05; margin = 0.005;
    x=0; y=0;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Show:",
      size: fontSize,
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "<Show Name>",
      size: fontSize,
      key: '/eos/out/show/name',
      hAlign: 'left',
      stroke: '#fff',
    }) );

    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Current Cue:",
      size: fontSize,
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "<Current Cue Text>",
      size: fontSize,
      key: '/eos/out/active/cue/text',
      hAlign: 'left',
      stroke: '#fff',
    }) );

    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Cue Progress:",
      size: fontSize,
    }) );
    panel.add( new Interface.Slider({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      key: '/eos/out/active/cue',
      isVertical: false,
      // stroke: '#fff',
      changeValue: function( xOffset, yOffset ) {},
    }) );

    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Next Cue:",
      size: fontSize,
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "<Next Cue Text>",
      size: fontSize,
      key: '/eos/out/pending/cue/text',
      hAlign: 'left',
      stroke: '#fff',
    }) );

    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Channel:",
      size: fontSize,
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "<Channel Text>",
      size: fontSize,
      key: '/eos/out/active/chan',
      hAlign: 'left',
      stroke: '#fff',
    }) );

    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Command:",
      size: fontSize,
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "<Command Line Text>",
      size: fontSize,
      key: '/eos/out/cmd',
      hAlign: 'left',
      stroke: '#fff',
    }) );


    x_base=.00; y_base=0.30; button_width=.20; button_height=.10; margin = 0.010;
    x=0; y=0;
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/shift',
      mode: 'toggle',
      label: 'Shift',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/macro',
      mode: 'momentary',
      label: 'Macro',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/park',
      mode: 'momentary',
      label: 'Park',
    }) );
/*
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/update',
      mode: 'momentary',
      label: 'Update',
    }) );
*/

    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
//      target: "WebSocket", key: '/eos/key/fixture_global_reset',
      target: "WebSocket", key: '/eos/cmd/Lamp_Control/Fixture_Global_Reset',
      mode: 'momentary',
      label: 'Fixt.Reset',
    }) );
//    x++;

    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/record',
      mode: 'momentary',
      label: 'Record',
    }) );

    y++; x=0;
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/go_to_cue',
      mode: 'momentary',
      label: 'Go To Cue',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/cue',
      mode: 'momentary',
      label: 'Cue',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/group',
      mode: 'momentary',
      label: 'Group',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/sub',
      mode: 'momentary',
      label: 'Sub',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/time',
      mode: 'momentary',
      label: 'Time',
    }) );

    y++; x=0;
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/+',
      mode: 'momentary',
      label: '+',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/thru',
      mode: 'momentary',
      label: 'Thru',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/-',
      mode: 'momentary',
      label: '-',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/\\',
      mode: 'momentary',
      label: '/',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/sneak',
      mode: 'momentary',
      label: 'Sneak',
    }) );

    y++; x=0;
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/7',
      mode: 'momentary',
      label: '7',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/8',
      mode: 'momentary',
      label: '8',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/9',
      mode: 'momentary',
      label: '9',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/rem_dim',
      mode: 'momentary',
      label: 'Rem Dim',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/address',
      mode: 'momentary',
      label: 'Address',
    }) );

    y++; x=0;
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/4',
      mode: 'momentary',
      label: '4',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/5',
      mode: 'momentary',
      label: '5',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/6',
      mode: 'momentary',
      label: '6',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/out',
      mode: 'momentary',
      label: 'Out',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/last',
      mode: 'momentary',
      label: 'Last',
    }) );

    y++; x=0;
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/1',
      mode: 'momentary',
      label: '1',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/2',
      mode: 'momentary',
      label: '2',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/3',
      mode: 'momentary',
      label: '3',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/full',
      mode: 'momentary',
      label: 'Full',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/next',
      mode: 'momentary',
      label: 'Next',
    }) );

    y++; x=0;
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/clear_cmd',
      mode: 'momentary',
      label: 'Clear',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/0',
      mode: 'momentary',
      label: '0',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/.',
      mode: 'momentary',
      label: '.',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/@',
      mode: 'momentary',
      label: 'At',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/enter',
      mode: 'momentary',
      label: 'Enter',
    }) );

  return panel; }




/***************************************************************************************\
*                                                                                       *
*                                 PLAYBACK PANEL                                        *
*                                                                                       *
\***************************************************************************************/

  function make_playback_panel () {
    
    panel = new Interface.Panel({
      useRelativeSizesAndPositions: true,
      container:document.querySelector("#osc_panel"),
    });
    panel.background = '#222';
    panel.canvas.style.width = '100%';
    panel.canvas.style.height = '100%';
    panel.font = 'normal '+fontSize+'px sans-serif';

    var x_base, y_base, button_width, button_height, margin, x, y;

    x_base=.00; y_base=.00; button_width=.20; button_height=.05; margin = 0.005;
    x=0; y=0;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Show:",
      size: fontSize,
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-0.2-button_width)-2*margin, button_height-2*margin],
      value: "<Show Name>",
      size: fontSize,
      key: '/eos/out/show/name',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+0.80+margin, y_base+y*button_height+margin, 0.2-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/osc/enable/playback',
      mode: 'toggle',
      label: 'Enabled',
      value: 1,
      background: '#f00', // fill colour (when not pressed)
      stroke: '#000',     // text colour, and border colour
      fill: '#0f0',       // fill colour (when pressed)
      onvaluechange: function() {
        if (this.value) {
          this.label = "Enabled";
          for ( var j in this.panel.children) {
            if (this.panel.children[j].disableable) {
              var child = this.panel.children[j];
              if (child.enabledProperties) {
                child.changeValue = child.enabledProperties.changeValue;
                child.background = child.enabledProperties.background;
                child.stroke = child.enabledProperties.stroke;
                child.fill = child.enabledProperties.fill;
                child.refresh();
              }
            }
          }
        } else {
          this.label = "Disabled";
          for ( var j in this.panel.children) {
            if (this.panel.children[j].disableable) {
              var child = this.panel.children[j];
              if (! child.enabledProperties) {
                child.enabledProperties = {}
                child.enabledProperties.changeValue = child.changeValue;
                child.enabledProperties.background = child.background;
                child.enabledProperties.stroke = child.stroke;
                child.enabledProperties.fill = child.fill;
              }
              child.changeValue = function(xOffset, yOffset) {};
              child.background = this.panel.background;
              child.stroke = this.panel.childStroke;
              child.fill = this.panel.background;
              child.refresh();
            }
          }
        }
      }
    }) );

/*
    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Current Cue:",
      size: fontSize,
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "<Current Cue Text>",
      size: fontSize,
      key: '/eos/out/active/cue/text',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );
*/
    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.20, y_base+y*button_height+margin, 0.10, button_height-2*margin],
      value: "Cue",
      size: fontSize,
      hAlign: 'left',
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.30, y_base+y*button_height+margin, 0.55, button_height-2*margin],
      value: "Label",
      size: fontSize,
      hAlign: 'left',
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.85, y_base+y*button_height+margin, 0.15, button_height-2*margin],
      value: "Time",
      size: fontSize,
      hAlign: 'left',
      vAlign: 'middle',
    }) );
    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, 0.2-margin, button_height-2*margin],
      value: "Current:",
      size: fontSize,
      // hAlign: 'left',
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.20, y_base+y*button_height+margin, 0.10, button_height-2*margin],
      value: "??",
      size: fontSize,
      key: '/eos/out/active/cue/text/number',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.30, y_base+y*button_height+margin, 0.55, button_height-2*margin],
      value: "????",
      size: fontSize,
      key: '/eos/out/active/cue/text/label',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.85, y_base+y*button_height+margin, 0.15, button_height-2*margin],
      value: "??",
      size: fontSize,
      key: '/eos/out/active/cue/text/time',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );

    panel.add( new Interface.Slider({
      bounds: [x_base+0.20, y_base+(y+1)*button_height-margin, 0.8-margin, 1.5*margin],
      key: '/eos/out/active/cue',
      isVertical: false,
      background: '#770',
      stroke: panel.background,
      fill: '#ff0',
      changeValue: function( xOffset, yOffset ) {},
    }) );

    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, 0.2-margin, button_height-2*margin],
      value: "Pending:",
      size: fontSize,
      // hAlign: 'left',
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.20, y_base+y*button_height+margin, 0.10, button_height-2*margin],
      value: "??",
      size: fontSize,
      key: '/eos/out/pending/cue/text/number',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.30, y_base+y*button_height+margin, 0.55, button_height-2*margin],
      value: "????",
      size: fontSize,
      key: '/eos/out/pending/cue/text/label',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.85, y_base+y*button_height+margin, 0.10, button_height-2*margin],
      value: "??",
      size: fontSize,
      key: '/eos/out/pending/cue/text/time',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );

/*
    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Cue Progress:",
      size: fontSize,
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Slider({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      key: '/eos/out/active/cue',
      isVertical: false,
      // stroke: '#fff',
      changeValue: function( xOffset, yOffset ) {},
    }) );
*/

/*
    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Next Cue:",
      size: fontSize,
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "<Next Cue Text>",
      size: fontSize,
      key: '/eos/out/pending/cue/text',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );
*/

/*
    y++;
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Channel:",
      size: fontSize,
      vAlign: 'middle',
    }) );
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      value: "<Channel Text>",
      size: fontSize,
      key: '/eos/out/active/chan',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );
*/

    y++;
/*
    panel.add( new Interface.Label({
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: "Command:",
      size: fontSize,
      vAlign: 'middle',
    }) );
*/
    panel.add( new Interface.Label({
//      bounds: [x_base+0.00+button_width+margin, y_base+y*button_height+margin, (1.0-button_width)-2*margin, button_height-2*margin],
      bounds: [x_base+0.00+margin, y_base+y*button_height+margin, 1.0-2*margin, button_height-2*margin],
      value: "<Command Line Text>",
      size: fontSize,
      key: '/eos/out/cmd',
      hAlign: 'left',
      vAlign: 'middle',
      stroke: '#fff',
    }) );


    x_base=.00; y_base=0.30; button_width=.20; button_height=.10; margin = 0.010;
    x=0; y=0;

    y++; x=0;

    x++;
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+y*button_height+margin, (button_width*3)-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/key/stop',
      mode: 'momentary',
      label: 'Stop/Back',
      background: '#900', // fill colour (when not pressed)
      stroke: '#ccc',     // text colour, and border colour
      fill: '#f00',       // fill colour (when pressed)
      disableable: true,
    }) ); x+=3;

    y++; x=0;

    y++; x=0;
    x++;
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+y*button_height+margin, (button_width*3)-2*margin, (button_height*3)-2*margin],
      target: "WebSocket", key: '/eos/key/go_0',
      mode: 'momentary',
      label: 'Go!',
      background: '#090', // fill colour (when not pressed)
      stroke: '#ccc',     // text colour, and border colour
      fill: '#0f0',       // fill colour (when pressed)
      relativeFontSize: 3,
      font: 'normal '+(3*fontSize)+'px sans-serif',
      disableable: true,
    }) ); y+=3; x=0;

  return panel; }




/***************************************************************************************\
*                                                                                       *
*                                   FADERS PANEL                                        *
*                                                                                       *
\***************************************************************************************/

  function make_faders_panel () {
    
    panel = new Interface.Panel({
      useRelativeSizesAndPositions: true,
      container:document.querySelector("#osc_panel"),
    });
    panel.background = '#222';
    panel.canvas.style.width = '100%';
    panel.canvas.style.height = '100%';
    panel.font = 'normal '+fontSize+'px sans-serif';

    var x_base, y_base, button_width, button_height, margin, x, y;

    x_base=.00; y_base=0.00; button_width=.20; button_height=.10; margin = 0.010;
    x=0; y=0;
    var fader_bank=1;
    var faders={};
    faders.page={};
    for (var page=1; page<=4; page++) {
      panel.add( faders.page[page] = new Interface.Button({
        bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
        target: "WebSocket", key: '/eos/fader/'+fader_bank+'/config/'+page+'/5',
        mode: 'toggle',
        label: 'Page '+page,
        page: page,
        onvaluechange: function() {
          for ( var page in faders.page) {
            faders.page[page].setValue(this.page==page ? 1 : 0);
          }
        },
      }) );
    }
    panel.add( faderPageLabel = new Interface.Label({
      bounds: [x_base+(x++)*button_width+margin, y_base+y*button_height+margin, button_width-2*margin, button_height-2*margin],
      value: 'Page: ?',
      size: fontSize,
      vAlign: 'middle',
    }) );
    Interface.OSC.callbacks['/eos/out/fader/'+fader_bank] = function(args) {
      // console.log( args )
      faderPageLabel.setValue('Page: ' + args[0]);
      for ( var page in faders.page) {
        faders.page[page].setValue(args[0]==page ? 1 : 0);
      }
    }

    x_base=.00; y_base=0.10; button_width=.20; button_height=.05; margin = 0.005;
    x=0; y=0;
    fader_height=10;

    for (var fader=1; fader<=5; fader++) {
    faders[fader] = {};

    panel.add( new Interface.Label({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height, button_width-2*margin, button_height],
      value: "Fader "+fader,
      key: '/eos/out/fader/'+fader_bank+'/'+fader+'/name',
      size: fontSize,
      vAlign: 'middle',
    }) );
    panel.add( faders[fader].fader = new Interface.Slider({
      bounds: [x_base+x*button_width+margin, y_base+(y)*button_height+margin, button_width-2*margin, button_height*fader_height-2*margin],
      value: 0,
      key: '/eos/fader/'+fader_bank+'/'+fader,
      // stroke: '#fff',
      fader: fader,
      onvaluechange: function() {
        faders[this.fader].value.setValue( (this.value*100).toString().substring(0, 4)+'%' );
      },
    }) );
    y+=fader_height;
    panel.add( faders[fader].value = new Interface.Label({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height, button_width-2*margin, button_height],
      value: "0",
      size: fontSize,
      vAlign: 'middle',
    }) );

/*
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/fader/'+fader_bank+'/'+fader+'/+%',
      mode: 'momentary',
      label: '+%',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/fader/'+fader_bank+'/'+fader+'/-%',
      mode: 'momentary',
      label: '-%',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/fader/'+fader_bank+'/'+fader+'/level',
      mode: 'momentary',
      label: 'Level',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/fader/'+fader_bank+'/'+fader+'/out',
      mode: 'momentary',
      label: 'Out',
    }) );
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height-2*margin],
      target: "WebSocket", key: '/eos/fader/'+fader_bank+'/'+fader+'/fire',
      mode: 'momentary',
      label: 'Fire',
    }) );
*/

    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height*2-2*margin],
      target: "WebSocket", key: '/eos/fader/'+fader_bank+'/'+fader+'/full',
      mode: 'momentary',
      label: 'Full',
    }) );
    y++;
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height*2-2*margin],
      target: "WebSocket", key: '/eos/fader/'+fader_bank+'/'+fader+'/out',
      mode: 'momentary',
      label: 'Out',
    }) );
    y++;
    panel.add( new Interface.Button({
      bounds: [x_base+x*button_width+margin, y_base+(y++)*button_height+margin, button_width-2*margin, button_height*2-2*margin],
      target: "WebSocket", key: '/eos/fader/'+fader_bank+'/'+fader+'/fire',
      mode: 'momentary',
      label: 'Fire',
    }) );
    y++;

    x++; y=0;
    
    }
    Interface.OSC.callbacks['/eos/fader/'+fader_bank+'/1'] = function(args) {
      // console.log( args )
      //   args -> array of arugments from the OSC message (only item 1 for fader values)
      // console.log( this )
      //   this -> Interface.OSC.callbacks
      faders[1].fader.setValue( args[0] );
      faders[1].value.setValue( (args[0]*100).toString().substring(0, 4)+'%' );
    }
    Interface.OSC.callbacks['/eos/fader/'+fader_bank+'/2'] = function(args) {
      // console.log( args )
      faders[2].fader.setValue( args[0] );
      faders[2].value.setValue( (args[0]*100).toString().substring(0, 4)+'%' );
    }
    Interface.OSC.callbacks['/eos/fader/'+fader_bank+'/3'] = function(args) {
      // console.log( args )
      faders[3].fader.setValue( args[0] );
      faders[3].value.setValue( (args[0]*100).toString().substring(0, 4)+'%' );
    }
    Interface.OSC.callbacks['/eos/fader/'+fader_bank+'/4'] = function(args) {
      // console.log( args )
      faders[4].fader.setValue( args[0] );
      faders[4].value.setValue( (args[0]*100).toString().substring(0, 4)+'%' );
    }
    Interface.OSC.callbacks['/eos/fader/'+fader_bank+'/5'] = function(args) {
      // console.log( args )
      faders[5].fader.setValue( args[0] );
      faders[5].value.setValue( (args[0]*100).toString().substring(0, 4)+'%' );
    }

  return panel; }




  </script>
</body>
</html>